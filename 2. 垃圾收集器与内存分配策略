
1. 概述
  Program Counter Register，VM Stack和Native Method Stack随线程而生，随线程而灭，因此内存分配和回收都具有确定性
  Stack和Method Area只有在程序处于运行期间才知道要创建哪些对象实例，这部分内存的分配和回收是动态的

2. 判断对象是否存活
  1. 引用计数算法Reference Counting
    给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1，引用失效时，计数器减1，则任何时刻计数器为0的对象代表已不存活
    实现简单，判定效率高，无法解决对象之间的相互循环引用的问题
  2. 根搜索算法GC Roots Tracing
    通过一系列名为GC Roots的对象作为起始点，向下搜索，路径成为引用链Reference Chain，当从GC Roots到一个对象不可达时，则该对象不可用
    GC Roots对象包括VM Stack（栈帧中的本地变量表）中引用的对象、Method Area中类静态属性引用的对象和Method Area中常量引用的对象
  3. 引用类型
    强引用Strong Reference > 软引用Soft Reference > 弱引用Weak Reference > 虚引用Phantom Reference
  4. Method Area区的垃圾回收
    主要回收废弃常量和无用的类
    废弃常量：存在在常量池中，但没有被任何对象引用
    无用的类：该类所有的实例都已经被回收，加载该类的ClassLoader已经被回收，该类对应的java.lang.Class对象没有在任何地方被引用
    
3. 垃圾回收算法
  1. 标记-清除算法Mark-Sweep
    首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象
    标记和清除过程的效率不高，回收后产生大量不连续的内存碎片阻碍后续较大对象的内存分配
  2. 复制算法Copying
    将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完后，将仍然存活着的对象复制到另外一块上，再将之前已使用过的内存空间一次清理掉
    用于回收新生代（存活时间不长），对于HotSpot虚拟机，将内存分为Eden空间和两块Survivor空间（大小8:1），每次使用Eden和一块Survivor，回收时将Eden和Survivor中存活的对象拷贝到另一块Survivor上，再清理掉Eden和第一块Survivor
  3. 标记-整理算法Mark-Compact
    标记后将所有存活的对象向一端移动进行整理，再将端边界以外的内存清除，用于老年代（存活时间很长）
  4. 分代收集算法Generational Collection
    根据对象的存活周期的不同将内存划分为几块，并根据各自特点使用适合的收集算法
    
4. 垃圾收集器    
    
    
