
1. 概述
  Java虚拟机规定了虚拟机字节码执行引擎的概念模型，是各种虚拟机执行引擎的统一外观Facade
  执行引擎分为通过解释器执行的解释执行和通过即时编译器产生本地代码执行的编译执行
  Java虚拟机的执行引擎的外观：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果
  
2. 运行时栈帧结构
  栈帧Stack Frame是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的VM Stack的栈元素
  栈帧存储方法的局部变量表Local Variable Table、操作数栈Operand Stack、动态连接Dynamic Linking和方法返回地址Return Address，内存分配在编译器已经确定
  每一个方法从调用开始到执行完成的过程，对应着一个栈帧在VM Stack中从入栈到出栈的过程
  如果方法调用链很长，只有栈顶的栈帧是有效的，称为当前栈帧Current Stack Frame，这个栈帧所关联的方法称为当前方法Current Method，字节码只针对当前栈帧进行操作
  1. 局部变量表
    是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量
    局部变量表的容量以变量槽Variable Slot为最小单位，一个Slot可以存放32以内的数据类型
    在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程，对于实例方法，第0位索引的Slot存放方法所属对象实例的引用即可以用this访问该参数
    局部变量表中的Slot是可重用的，如果当前字节码PC计数器的值已经超过了某个变量的作用域，则该Slot可以被其他变量使用，节省栈空间，影响垃圾收集行为
    局部变量不存在类变量加载过程中的准备Preparation，因此局部变量不会被初始化零值，定义时需要赋初始值
  2. 操作数栈
    也称为操作栈，是一个LIFO栈，最大深度在编译的时候确定被写入到Code属性的max_stacks数据项
    当一个方法开始执行时，这个方法的操作数栈是空的，在执行过程中，会有各种字节码指令像操作数栈中写入和提取内容，即入栈出栈操作
    解释执行引擎是基于操作数栈的执行引擎
  3. 动态连接
    每个栈帧包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接
    Class文件的常量池中的符号引用中的一部分会在每一次的运行期间转化为直接饮用，称为动态连接
  4. 方法返回地址
    退出方法的方式有两种，第一种为正常完成出口Normal Method Invocation Completion是将返回值传递给上层的方法调用者，第二种为异常完成出口Abrupt Method Invocation Completion是遇到无法处理的异常
    
3. 方法调用
  1. 解析Resolution
    方法调用中的目标方法在Class文件里是一个常量池的符号引用，在类加载的解析Resolution阶段，一部分符号引用转化为直接引用，前提条件是调用目标有代码并且在编译器进行编译时必须确定
    符合编译期可知、运行期不可变的方法主要为静态方法、私有方法、实例构造器和父类方法，也称为非虚方法
    解析调用是一个静态过程，在编译期间确定，在类加载的解析阶段将有关的符号引用转化为直接引用
  2. 分派Dispatch
    静态分派与重载Overload有关，动态分派与重写Override有关
    1. 静态分派
      Human man = new Man();
      Human woman = new Woman();
      其中Human称为静态类型Static Type或外观类型Apparent Type，Man和Woman称为实际类型Actual Type，静态类型在编译期可知，实际类型在运行期才可以确定
      当存在多个重载Overload方法时，编译器通过参数的静态类型作为判定依据选择，该操作称为静态分派，发生在编译期间
      如果变量没有显式的静态类型例如字面量，编译器通过语言上的规则去推断，例如对于char类型，char->int->long->float->double->Character->Serializable->Object
    2. 动态分派
      Human man = new Man();
      Human woman = new Woman();
      并且在Man和Woman中重写Override继承来的方法
      首先建立man和woman的内存空间，调用Man和Woman类型的实例构造器，存放在局部变量表Slot中
      将创建的对象的引用压到栈顶，该对象是将要执行的方法的所有者，称为接收者Receiver
      执行方法调用invokevirtual指令，由于invokevirtual指令的多态查找，能够在运行期确定接收者的实际类型，因此将常量池中的类方法符号引用解析到各自对应的直接引用上，这个过程也是方法重写的本质
    3. 动态分派的实现
      常用的稳定优化的手段是为类在方法区中建立一个虚方法表Virtual Method Table，用来存放各个方法的实际入口地址
      如果某个方法在子类中没有被重写，该方法在子类的虚方法表中的地址入口和父类中该方法的地址入口相同
      如果子类中重写了某个方法，该方法在子类的虚方法表中的地址入口将会指向子类实现的入口地址，即指向子类的类型数据
    4. 单分派与多分派
      方法的接收者与方法的参数统称为方法的宗量
      单分派是根据一个宗量对目标方法进行选择，多分派是根据多个宗量对目标方法进行选择
      静态分派属于多分派，因为选择目标方法依赖于静态类型和方法参数
      动态分派属于单分派，因为选择目标方法只依赖于接收者的实际类型
    
4. 基于栈的字节码解释执行引擎
  程序源码->词法分析->单词流->语法分析->抽象语法树->指令流->解释器->解释执行
  





