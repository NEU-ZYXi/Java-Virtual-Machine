
1. 概述
  虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终行程可以被虚拟机直接使用的Java类型，这是虚拟机的类加载机制
  类型的加载和连接过程是在程序运行期间完成的，为程序提供高度的灵活性，Java的动态扩展特性依赖运行期动态加载和动态连接实现
  
2. 类加载的时机
  类的生命周期：加载Loading、验证Verification、准备Preparation、解析Resolution、初始化Initialization、使用Using和卸载Unloading，其中验证、准备和解析称为连接Linking
  有且只有四种情况对类进行初始化，称为对一个类的主动引用
  1. 遇到new、getstatic、putstatis或invokestatic
  2. 对类进行发射调用时
  3. 当初始化一个类时，如果其父类为进行过初始化，需要先触发其父类的初始化
  4. 当虚拟机启动时，需要指定一个可执行的main class，虚拟机会先初始化这个主类
                        
3. 类加载的过程
  1. 加载Loading
    虚拟机需要完成通过一个类的全限定名来获取定义此类的二进制字节流、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构、在Heap中生成一个该类的对象作为方法区数据的访问入口
  2. 验证Verification
    包括文件格式、元数据、字节码、符号引用验证
  3. 准备Preparation
    是正式为类变量分配内存并设置类变量初始值的阶段，在方法区中进行分配
    此时进行内存分配的仅包括类变量即被static修饰的变量，而不包括实例变量，实例变量在对象实例化时随对象一起分配在Heap中
    设置初始值表示初始化数据类型的零值
  4. 解析Resolution
    是虚拟机将常量池中的符号引用替换为直接引用的过程
    符号引用Symbolic Reference是以一组符号来描述所引用的目标，可以是任何形式的字面量，引用的目标也不一定已经加载到内存中
    直接引用Direct Reference可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，引用的目标已经在内存中存在
    包括类或接口、字段、类方法、接口方法解析
  5. 初始化Initialization
    开始执行类中定义的Java程序代码ByteCode，是执行类构造器<clinit>()方法的过程
    <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块合并产生
    <clinit>()方法与类的构造函数<init>()不同，不需要调用父类构造器，虚拟机会保证父类<clinit>()方法已经执行完毕
    虚拟机保证<clinit>()方法在多线程下被正确地加锁和同步，只有一个线程去执行该类的<clinit>()方法
    
4. 类加载器
  类加载器实现了通过一个类的全限定名来获取描述此类的二进制字节流
  1. 类与类加载器
    对于任意一个类，需要由加载它的类加载器和这个类本身一起确立其唯一性，即只有在两个类是由同一个类加载器加载的时才可能相等
  2. 双亲委派模型Parentes Delegation Model
    对于Java虚拟机，只有两种类加载器，启动类加载器Bootstrap ClassLoader、所有其他类加载器继承自抽象类ClassLoader其中包括扩展类加载器Extension ClassLoader和应用程序类加载器Application ClassLoader
    这种模型即为双亲委派模型，除了顶层的Bootstrap ClassLoader之外，其余类加载器都需要有父类加载器
    工作过程是如果一个类加载器收到了类加载的请求，首先把这个请求委派给父类加载器去完成，只有当父类加载器反馈无法完成时，子类加载器才会去加载
    这种带有优先级的层次关系，使一些基础类都被委派给Bootstrap ClassLoader进行加载，保证了类的稳定性
    
      



