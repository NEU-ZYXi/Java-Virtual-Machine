
1. 概述
  Java程序最初通过解释器Interpreter进行解释执行，当虚拟机发现某个代码块的运行特别频繁时，将其认定为热点代码Hot Spot Code并由即时编译器Just In Time Compiler编译成与本地平台相关的机器码
  
2. HotSpot虚拟机内的即时编译器JIT Compiler
  1. 解释器与编译器
    HotSpot采用解释器和编译器并存的架构
    当程序需要迅速启动和执行时，解释器首先发挥作用立即执行代码，程序运行后，编译器逐渐将代码编译成本地代码后，获得更高的执行效率
    虚拟机有两个即时编译器，称为Client Compiler和Server Compiler，简称为C1编译器和C2编译器
    虚拟机默认采用解释器与其中一个编译器配合工作，称为混合模式Mixed Mode，用户可切换成解释模式Interpreted Mode或者编译模式Compiled Mode
    采用分层编译Tiered Compilation的策略，Client Compiler和Server Compiler会同时工作，根据编译器编译、优化的规模与耗时，划分出不同的编译层次
      1. 第0层：程序解释执行，解释器不开启性能监控Profiling功能，在有需要的时候触发第1层编译
      2. 第1层：称为C1编译，将字节码编译成本地代码，进行简单优化，也可以加入性能监控
      3. 第2层及以上：称为C2编译，将字节码编译成本地代码，启用编译耗时较长的优化，根据性能监控信息进行调优
  2. 编译对象与触发条件
    热点代码包括被多次调用的方法和被多次执行的循环体
    编译器对这两种热点代码都会以整个方法作为编译对象，并且这种编译方式发生在方法执行过程中，称为栈上替换On Stack Replacement即OSR
    采用热点探测Hot Spot Detection判断一段代码是不是热点代码
      1. 基于采样的热点探测Sample Based Hot Spot Detection：周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，则为热点方法
      2. 基于计数器的热点探测Counter Based Hot Spot Detection：为每个方法建立计数器，统计执行次数
    HotSpot虚拟机采用第二种热点探测，为每个方法建立方法调用计数器Invocation Counter和回边计数器Back Edge Counter
      1. Invocation Counter
        Java方法入口 -> 判断是否存在已编译版本 -> 若为否，则方法调用计数器值加1 -> 判断两个计数器之和是否超过阈值 -> 若为是，则向编译器提交编译请求 -> 以解释方式执行方法 -> Java方法返回 -> 编译完成后改写方法入口
        如果超过一定时间某方法调用次数未超过阈值，进行热度衰减Counter Decay，计数器数值减半，这段时间称为半衰周期Counter Half Life Time
      2. Back Edge Counter
        在字节码中遇到控制流向后跳转的指令称为回边Back Edge，统计一个方法中循环体代码执行的次数，超过阈值则提交一个OSR编译请求
        Java方法入口 -> 判断是否存在已编译版本 -> 若为否，则回边计数器值加1 -> 判断两个计数器之和是否超过阈值 -> 若为是，则向编译器提交OSR编译请求 -> 调整回边计数器值 -> 以解释方式执行方法 -> Java方法返回 -> 编译完成后改写方法入口
        回边计数器没有热度衰减的过程，可以溢出
        
3. 编译优化技术
  1. 公共子表达式消除Common Subexpression Elimination
    如果一个表达式已经被计算过，并且该表达式中的变量值都没有发生变化，则为公共子表达式，不再进行重复计算
  2. 数组范围检查消除Array Bounds Checking Elimination
    通过数据流分析来消除每次访问第i个元素时隐含的上下界范围检查
  3. 方法内联Method Inlining
    消除方法调用的成本，并且通过方法内联来发现无用代码Dead Code，但是对于Java中常见的虚方法，由于在编译期间无法确定实际类型，选择激进优化，遇到异常通过逆优化Deoptimization回到解释执行
  4. 逃逸分析Escape Analysis
    用于分析对象动态作用域，即当一个对象在方法里被定义后，它可能被外部方法所引用，例如作为参数传递到其他方法中，这种行为称为方法逃逸
    如果可以确定一个对象不会逃逸，可以进行一些高效优化
      1. 栈上分配Stack Allocation
        由于在堆上分配创建对象的内存空间时，对于各个线程都是共享并且可见，只要持有该对象的引用就可以访问该对象数据，GC会回收掉堆中不再使用的对象，这一些过程都会耗费时间，因此将不会逃逸的对象进行栈上分配以优化
      2. 同步消除Synchronization Elimination
        对于不会逃逸出线程的变量，无法被其他线程访问，对该变量的同步措施可以消除
      3. 标量替换Scalar Replacement
        对于不会逃逸的对象，程序在执行中可能不会创建该对象，而是将它使用到的成员变量恢复到原始类型Primitive Type即标量Scalar来访问
        
    


